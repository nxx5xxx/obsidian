### 의미
> 사전적의미 : 두 장치를 연결하는 접속기  
> 자바에서의 의미 : 서로 다른 객체를 연결하는 역할을 하는 객체(인터페이스)  
> 예를 들어 컨트롤러라는 객체는 인터페이스를 통해 서비스 임플리먼츠를 사용할 수 있다.  
> 컨트롤러가 인터페이스의 메소드를 호출하면 인터페이스는 ServiceImpl의 메소드를 호출하고  
> 그 결과를 받아와 Controller에 전달한다. (스프링에서)  

### 사용 이유
> 직접 ServiceImpl의 메소드를 호출 시키면 되지 왜 굳이 인터페이스를 거쳐 호출할까?  
> 예를들어 FirstServiceImpl이라는 객체의 메소드를 인터페이스 없이 직접 사용하고 있다면  
> SecondServiceImpl이라는 객체의 메소드로 전체적으로 바꿔주어 사용해야 할때  
> 그 메소드를 사용하고 있는 Controller에서도 소스코드를 수정해줘야한다  
> 하지만 인터페이스를 참조하고있고 인터페이스를 Implements(구체화) 하여 사용하는 경우에는  
> Override하는 부분의 객체만 바꿔주면 되기 때문  
> 이 특징으로 인해 인터페이스는 다형성 구현에서 주된 기술로 사용된다  
> 상속을 이용하여 다형성을 구현할 수 도 있지만 인터페이스를 이용하여 다형성을 구성하는 경우가 더 많다.

----

### 선언방법
> 클래스와 거의 유사하지만 클래스 부분 대신에 interface가 들어간다는게 다르다  
> 
```
public interface 인터페이스명 { ~ }  
```

> 이런식으로 선언하게 된다  

#### 멤버
> public 상수 필드;  
> public 추상,디폴트,정적 메소드;  
> private 메소드,정적 메소드  
> 등이 멤버로 존재할 수 있다.

##### 추상메소드
> 추상메소드란 선언부만 있고 실행중인 중괄호가 없는 메소드를 뜻한다.  
> abstract와 흡사하다.

#### 구현 클래스 선언
> 인터페이스가 추상체라면 그를 구현해야하는 구현체가 필요할 것이다  
> 구현해내는 구현체는 implements(구현하다) 를 사용하여 명시할 수 있다.  
> public class Example implements 인터페이스명 { ~ }  

---
### 구현객체대입
> Animal 이라는 인터페이스가 있고 Dog이라는 구현체가 있다고 가정하자  
> 이 때  
> Animal animal;  
> 과 같이 변수의 타입으로 선언할 수 있고  
> 인터페이스는 레퍼런스타입에 속하므로 null 을 대입하여  
> Animal animal = null 과 값이 초기화 해줄 수 도 있다.  
> 또한 인터페이스를 통해 구현객체를 사용하려면  
> animal = new Dog();  
> 과 같이 구현객체를 대입해 줄 수 있다.(이는 dog객체를 생성하고 번지를 대입한다고 말하기도 한다)  
> 물론,  
> Animal animal = new Dog(); 처럼 대입 할 수도 있다.

---

### 상수필드
> 인터페이스는 public static final 특성을 갖는 불변의 상수 필드를 멤버로 가질 수 있다.  
> 인터페이스에 선언된 필드(변수) 는 모두 public static final 특성을 갖고있어  
> 해당 구문을 생략하더라도 컴파일시에 자동적으로 붙게된다.  
```
[public static final] 타입 상수명 = 값 ; 
```

#### 관례
> 상수명은 대문자로 하는것이 관례이며 다른 단어가 들어갈 시 언더바(\_)로 구분짓는게 관례이다  
> 예시 :  
> SNAKE_CASE 이런식 으로 말이다  

#### 예시
> public interface Example{  
> 	double PI = 3.141592;
> 	int MAX_VOLUME = 10;
> 	int MIN_VOLUME = 0;
> }

#### 참고사항
> 상수는 구현객체와 관련 없는 인터페이스 소속 멤버이므로 바로 접근하여 상수값을 사용할 수 있다.
> 예시 :  
> System.out.println("파이값은 : "+Example.PI);  

---

### 추상메소드2
> 인터페이스는 구현클래스가 재정의해야하는 public 추상 메소드를 멤버로 가질 수 있다
> 추상메소드는 리턴타입,메소드명,매개변수만 기술되고 중괄호를 붙이지 않는 메소드를 뜻하며  
> public abstract 를 생략하더라도 컴파일 과정에서 자동으로 붙는다.

#### 예시
> public interface Example{  
> 	public abstract void ExampleMethod();
> }

#### 역할
> 추상메소드는 인터페이스를 호출하는 객체가 어떻게 메소드를 호출 할 수 있는지 알려주는 역할만 한다. 실제 코드를 갖고있는 즉 실행부를 갖는 재정의된 메소드를 호출하여 정보가 은닉된 메소드를 실행시키는것 

---

### 디폴트메소드
>인터페이스에서 실행코드를 갖는 메소드를 정의하고 싶을 때 쓰이는 메소드이다  
>즉, 추상 메소드에는 실행부가 없지만 디폴트 메소드에는 실행부가 있다.  
>선언방법은 클래스의 메소드와 동일한데 default앞에 public이 생략되어있다는 점이 있다.  
>
#### 사용법
```
[public] default 리턴타입 메소드명(매개변수1,매개변수2 ...){
 실행코드
}
```

#### 예시
>default void defaultMethod(String str){  
>	System.out.println("디폴트메소드입니당"+str);
> }

#### 주의사항
> 디폴트 메소드는 구현 객체가 필요한 메소드이다  
> 따라서 디폴트 메소드를 호출하려면 구현객체를 인터페이스 변수에 대입하고 나서 호출해야 한다.

---

### 정적메소드
> 추상 메소드와 디폴트 메소드는 구현객체가 필요하지만,  
> 정적 메소드는 구현 객체 없이 인터페이스 만으로도 호출이 가능하다.  
> 선언 방법은 일반적인 클래스의 정적 메소드의 선언 방식과 동일하며  
> public은 생략하더라도 컴파일 과정에서 자동으로 붙게된다.

#### 사용법
```
[public or private] static 리턴타입 메소드명(매개변수1,매개변수2)...
```

#### 사용예시
```
public interface Example {
	public static void exampleMethod(){
		System.out.println("스태틱메소드");
	}
}
```

```
public class StaicMethodTest{
	public static void main(String[] args){
		Example.exampleMethod();
	}
}
```
> 이런식으로 정적 메소드를 바로 접근하여 사용 가능하다

---

### private 메소드
> 인터페이스에서 private메소드는 default메소드와 정적메소드에서  
> 사용이 가능하다 단, default 메소드는 구현객체가 필요하다는 점을 유의해야 할것같다.

#### 용도
> 보통 private 메소드는 중복 코드를 줄이기 위함이라 보면된다.

#### 사용예시
```
public interface Example {
	default void defaultMethod(){
		System.out.println("디폴트메소드에서 프리베이트 메소드 사용하기");
		defaultPrivate();
	}
	private void defaultPrivate(){
		System.out.println("defaultPrivate");
	}
	
	public static void staticMethod(){
		System.out.println("정적메소드에서 프리베이트 메소드 사용하기");
		staticPrivate();
	}
	private static void staticPrivate(){
		System.out.println("staticPrivate");
	}
}
```

```
public class Exam implements Example{

}
```

```
public class StaicMethodTest{
	public static void main(String[] args){
		Exam exam = new Exam();
		exam.defaultMethod();

		Example.staticMethod();
	}
}
```

> default 와 static의 차이로 볼 수 있다

---

### 다중 인터페이스 구현
> 구현 객체는 여러 개의 인터페이스를 구현 할 수 있다(implements).  
> 구현 객체가 인터페이스A와 인터페이스 B 를 구현하고 있다면  
> 각각의 인터페이스를 통해 구현 객체를 사용할 수 있다.

#### 사용법
```
public class 구현클래스명 implements 인터페이스A , 인터페이스B {
	// 모든 메소드 오버라이딩(재정의)
}
```

#### 주의사항
```
인터페이스A 변수 = new 구현객체명();
인터페이스B 변수 = new 구현객체명();
```
> 이와 같이 어떤 인터페이스 변수에 대입되느냐에 따라 호출할 수 있는 추상메소드가 결정 된다.

---

### 인터페이스 상속
> 인터페이스도 다른 인터페이스를 상속 받을 수 있으며 이 때는 implements가 아닌 extends(확장)  
> 을 사용하여 상속받는다 그리고 클래스와 다르게 다중 상속을 허용한다.

#### 사용법
```
public interface 자식인터페이스 extends 부모인터페이스A, 부모인터페이스B {

}
```

#### 주의사항
> 자식 인터페이스의 구현클래스는 자식뿐만 아니라 부모인터페이스의 모든 추상메소드까지 오버라이딩 하여야 한다.  그리하여 구현객체는 자식 및 부모 인터페이스 변수에 대입될 수있다.
```
자식인터페이스 변수명 = new 구현객체();
부모인터페이스A 변수명 = new 구현객체();
부모인터페이스B 변수명 = new 구현객체();
```

---

### 타입변환
>인터페이스 변수에 구현 객체를 대입하면 구현 객체는 인터페이스 타입으로 자동 타입 변환된다.   
>반대로 인터페이스 타입을 구현 클래스 타입으로 변환 시킬수 있지만 이 때는 강제 타입 변환이 필요하다.

#### 자동 타입 변환(=promotion)
##### 의미
> 말 그대로 자동으로 타입변환이 일어나는것을 말한다.

##### 예시
```
인터페이스 변수명 = 구현객체;

이 때 구현객체는 인터페이스 타읍오로 자동타입 변환이 된다.
```

##### 참고사항
> 부모 클래스가 인터페이스를 구현하고 있다면 해당 부모클래스의 자식클래스 또한 같은 인터페이스 타입으로 자동변환 될 수 있다. 이해가 안가면 아래 테이블을 보자

|  | 인터페이스A |  |
| ---- | ---- | ---- |
| 부모 클래스B |  | 부모 클래스C |
| (상속) |  |  |
| 자식 클래스D |  | 자식 클래스E |
> 참고로 얘네는 인터페이스 A를 구현하는 부모클래스 B와 C이다  
> 모두 같은 인터페이스 A를 구현해주므로 아래 테이블과 같이

| B b = new B(); |
| ---- |
| C c = new C(); |
| D d = new D(); |
| E e = new E(); |

| A a; |  |
| ---- | ---- |
| a = b; |  |
| a = c; |  |
| a = d; |  |
| a = e; | 다 가능 |
> 모두 인터페이스 A로 자동타입 변환이 가능해지는 것이다.


#### 강제 타입 변환(=casting)
> 강제 타입 변환은 캐스팅 기호를 사용하여 인터페이스 타입을 구현 클래스 타입으로 변환 시키는 것을 의미한다.

##### 예시
```
구현클래스타입 변수 = (구현클래스타입) 인터페이스변수;

```
> 구현 객체가 인터페이스 타입으로 자동 변환 되면, 인터페이스에 선언된 메소드만 사용 가능하다.
> 아래 예시2를 봐보자

##### 예시2
###### 인터페이스
| Dog |
| ---- |
| run(); |
| walk(); |
| sit(); |
###### 구현클래스
| Animal |
| ---- |
| run(){}; |
| walk(){}; |
| sit(){}; |
| howl(){}; |
| fly(){}; |
> 이와 같이 Dog라는 인터페이스와 Animal 이라는 구현 클래스가 있을 때  
> 인터페이스 에는 3개의 메소드 클래스에는 5개의 메소드가 있다.  
> 하지만 구현객체가 인터페이스로 자동 변환되게 되면 나머지 2개의 메소드를 사용하지 못하게 된다.(호출을 못하게됨)  
> 자동 타입 변환 후 howl()과 fly() 메소드를 호출하고 싶다면 다음과 같이 캐스팅 기호를 사용하여  
> 원래의 Aniaml클래스로 강제타입 변환해야한다.

```
Dog dog = new Animal();
dog.run();
dog.walk();
dog.sit();
```

```
Animal animal = (Animal) dog;
animal.run();
animal.walk();
animal.sit();
animal.howl();
animal.fly();
```

---
