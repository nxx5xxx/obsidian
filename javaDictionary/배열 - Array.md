#### 특징
> 변수는 한 개의 값만 저장이 가능하다.  
> 그 불편함을 해소하기 위해 만들어진것이 배열이다. 
> 예를 들어 10명의 점수를 입력한다 배열 없이는  
> int score1 = 50, score2 = 60 ...... score10 = 100;  
> 이런 식으로 작성해야 하지만 배열로 작성하게 되면  
> int\[] scoreArray = {50,60......,100}; 이렇게 가능한 것이다.
> 즉 배열은 연속된 공간에 값을 나열하고 각 값에 인덱스를 부여한 구조이다.

#### 특징2
> 배열은 같은 타입의 값만 넣을 수 있다.  
> 이미 생성된 배열의 길이는 늘리거나 줄일 수 없다.


#### 사용방법
> 타입\[] 변수 또는 타입 변수\[] 로 선언할 수 있으며  
> 타입\[] 변수 = {값0, 값1, 값2 ...... 값~}; 으로 초기화 할 수 있다.  
> 또 다른 방법으로는  타입\[] 변수 = new 타입\[길이]; 로  
> 기본값으로 초기화 된 배열을 선언 할 수 있다.  
> 여기서 기본값은 아래 참고자료를 참고하자.

##### 참고자료
|데이터 타입|초기값|
|---|---|
|기본타입||
|byte\[]|0|
|char\[]|'u0000'|
|short\[]|0|
|int\[]|0|
|long\[]|0|
|float\[]|0.0F|
|double\[]|0.0|
|boolean\[]|false|
|참조타입||
|클래스\[]|null|
|인터페이스\[]|null|


##### 주의사항
> 이미 선언한 배열에는 값을 대입 할 수 없다. 예를들어  
> int\[] a;  
> a = {1,10,50}; 이런 방식의 초기화는 불가능하며  
> a = new int\[] {1,10,50}; 이러한 방식으로 초기화를 해줘야 한다.

##### 주의사항2
> 메소드에서 매개변수가 배열 타입으로 주어졌을 경우에도  
> void test(int\[] a){ ~~~ }  
> test({1,10,50});  이런 방식으로 사용하는것은 불가능하고  
> test(new int\[] {1,10,50}); 이렇게 해줘야한다.

---
## 다차원 배열

### 특징
> 배열은 다차원 배열로 생성이 가능하다  
> 예를 들어 2차원 배열로 생성을 한다면  
> int\[]\[] arr = { {10,20,30} , {40,50} } 이런 방식으로도 생성이 가능하고  
> int\[]\[] arr2 = new int\[2]\[3] 이러한 방식으로도 생성이 가능하다.  
> 첫번째는 arr\[0] 의 길이는 3 arr\[1] 의 길이는 2로 서로 다른 길이를 갖고 있지만  
> 두번째 배열은 서로 같은 길이의 배열을 초기화 한것이다.

---
### 배열의 메모리구조
> 먼저 2차원 배열의 메모리 구조로 설명을 하겠다.
> int\[]\[] arr = { {10,20,30} , {40,50} } 라는 값을 초기화 하면  
> 아래와 같은 형태로 구조가 만들어진다.


|스택영역| |
|---|---|
|arr|arr의주소 : 예를들어 0xeerr9|

|힙 영역| | |
|---|---|---|---|
|0xeerr9|arr\[0] : 2eee1|arr\[1] : 2eee2|
||||
|2eee1|10|20|30|
|2eee2|40|50||

> 이렇게 생성되게 된다

---

### 배열의 복제
####  얕은복사
#얕은복사  #swallowcopy
> 배열의 복제 방법에는 여러가지가 있다. 먼저 한가지의 예를 들어 설명해보자면
> int\[] arr1 = {1, 10, 20, 30};  
> int\[] arr2 = arr1 ;  
> 와 같이 배열을 복사했다고 가정하자.  
> 이걸 굳이 왜 설명하나? 싶겠지만 이 배열을 아래와 같이 수정하여 출력해보면  
> arr2\[0] = 40;  
> System.out.println(Arrays.toString("arr1 : "+arr1));  
> System.out.println(Arrays.toString("arr2 : "+arr2));  
> 결괏값 :  
> arr1 : \[40, 10, 20, 30]  
> arr2 : \[40, 10, 20, 30]  
> 과 같이 두 배열이 다 바뀐것을 알 수 있다. 왜 이렇게 될까?  
> 그 전에 올려둔 자료들을 보면 변수들은 스택영역에 먼저 저장되고  
> 무언가를 대입할 때는 힙영역의 주소가 담겨있는 스택영역을 참조하게 되어있다  
> 아래 테이블을 보자  

|스택영역| |
|---|---|
|arr1|배열1의주소 : 82forof|

|힙영역| |
|---|---|---|---|---|
|82forof|1|10|20|30|

> 이런 식으로 arr1이 생성이 된다 감이오는가?  
> arr2에 arr1을 대입하게 되는 경우 결국 arr2도 같은 힙영역의 주소를 복사해오게 되는 것 이다.  

|스택영역| |
|---|---|
|arr1|배열1의주소 : 82forof|
|arr2|배열1의주소 : 82forof|

|힙영역| |
|---|---|---|---|---|
|82forof|1|10|20|30|

> 이러한 복사를 **얕은복사(swallow copy)** 라고 한다 얕은 복사의 특징으로는  
> 원본 배열 또는 카피된 배열의 구조를 바꿀 경우 원본과 원본으로부터 받아온 대상들은  
> 다같이 변경이 된다는 특징이 있다.  
> 위 처럼 arr2\[0] = 40; 을 하면 아래와 같이  


|스택영역| |
|---|---|
|arr1|배열1의주소 : 82forof|
|arr2|배열1의주소 : 82forof|

|힙영역| |
|---|---|---|---|---|
|82forof|40|10|20|30|

> 이 되는 걸 뜻하는 것이다

#### 깊은복사
> 위의 경우에는 얕은 복사로 원본 또는 복사본의 배열을 건들면 다 heap영역의 값이 같이 바뀐다  
> 이를 해결할수 있는 복사 방법은 깊은복사인데 깊은복사의 방법으로는 메소드를 사용하여  
> 복사하는 방법과 반복문을 사용하여 복사하는 방법이 있다.  

##### 사용 예시 - 반복문
> int\[] arr1 = {1, 10, 20, 30};  
> int\[] arr2 = new int\[arr1.length];  
> for(int i=0;i<arr1.length; i++){  
>  arr2\[i] = arr1\[i];
> }  
> 이와 같이 모든 인덱스에 접근하여 대입하여 저장하는 방식이다.

##### 사용 예시2 - clone()
#clone #깊은복사 #deepcopy
> 해당 방법은 java에서 기본으로 제공해주는 clone() 메소드를 사용하여 깊은 복제를 하는 방식이다.  해당 방법으로 복제를 하게되면 heap영역에 새로이 객체를 생성하여 저장하게 된다.  

> int\[] arr1 = {1, 10, 20, 30};  
> int\[] arr2 = arr1.clone();  
> 이렇게 간단하게 복사 할 수 있다.  

###### 주의사항
> 다차원 배열을 깊은복사 할 시에는  
>int\[]\[] arr1 = {{1, 2, 3, 4},{10,20,30}};  
>int\[]\[] arr2 = new int\[arr1.length]\[];  
>for(int i=0;i<arr1.length;i++) {  
>arr2\[i] = arr1\[i].clone();  
>}  
>이렇게 복사를 하여야 한다.

##### 사용 예시3 - System.arrayscopy
> 해당 메소드는 어떻게 보면 까다롭지만 상황에 따라 더 유용하게 쓰일 수 있는 방법이다.  
> System.arraycopy(원본배열명, 원본배열의 시작인덱스, 새로운배열명, 새배열의 붙여넣을인덱스 , 복사할 항목 개수); 로 사용한다  감이 안온다면 아래의 예시를 보자  

###### 예시3_2
>int\[] arr1 = {1, 10, 20, 30};  
>int\[] arr2 = new int[6];     
>System.arraycopy(arr1, 1, arr2, 1, arr1.length-1);  
>System.out.println(Arrays.toString(arr2));   
>결괏값 :  
>\[0, 10, 20, 30, 0, 0]  

> 여기서의 결괏값은 원본배열의 시작인덱스를 1(10)부터 복사해왔고  
> 새 배열의 붙여넣을 인덱스를 1번부터 시작했기에 이렇게 값이 나온것이다.  
> 여기서 주의할 점은 원본배열의 시작인덱스가 뒤로 밀림에 따라 복사할 항목 개수는 그 수만큼  
> 줄어들어야 한다 그렇지 않으면 java.lang.ArrayIndexOutOfBoundsException 예외가 발생한다.

##### 사용 예시4 - Arrays.copyOf
> System.arrayscopy 메소드를 사용하여 만들어진 메소드이다.  
> 붙여넣을 배열 = Arrays.copyOf(복사할 배열, 복사할 개수); 이러한 방식으로 사용이 가능하다   
> int\[] arr1 = {1, 10, 20, 30};  
> int\[] arr3 = Arrays.copyOf(arr1, 3);  
> System.out.println(Arrays.toString(arr3));  
> 결괏값 :  
>\[1, 10, 20]
>Arrays.copyOf메소드의 단점은 복사할 배열의 0번 인덱스가 고정 이라는것 이다.
>이를 보충해줄 메소드가 또 있는데 아래를 보자.

##### 사용 예시5 - Arrays.copyOfrange
> copyOf의 부족한 점을 보충해주는 복제 메소드이다.  
> 붙여넣을 배열 = Arrays.copyOfRange(복사할 배열, 시작 인덱스, 마지막 인덱스);  
> 의 방법으로 사용할 수 있으며 아래의 예제를 보자.  
> int\[] arr1 = {1, 10, 20, 30};  
> int\[] arr4 = Arrays.copyOfRange(arr1, 2, 3);  
> System.out.println(Arrays.toString(arr4));  
> 결괏값 :  
> \[20]


#### 주의사항
> substring처럼 마지막 인덱스에 바로 전까지만 복사한다

### 참고사항
>속도 측면에서 System.arrayscopy 가 Native 인터페이스를 사용하여 속도가 빠르다고 하지만  
>StackOverFlow에 따르면 clone과 Arrays.copyOf가 더 빠른것으로 나와있다.  
